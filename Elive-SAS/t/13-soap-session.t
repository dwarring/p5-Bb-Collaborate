#!perl
use warnings; use strict;
use Test::More tests => 20;
use Test::Exception;
use Test::Builder;
use version;

use lib '.';
use t::Elive::SAS;

use Elive::SAS::Session;

our $t = Test::Builder->new;
our $class = 'Elive::SAS::Session' ;

our $connection;

use Carp;
$SIG{__DIE__} = \&Carp::confess;

SKIP: {

    my $skippable = 20;

    eval 'require DateTime';
    skip('DateTime is required to run this test', $skippable)
	if $@;

    my %result = t::Elive::SAS->test_connection();
    my $auth = $result{auth};

   skip ($result{reason} || 'skipping live tests', $skippable)
	unless $auth && @$auth;

    use Elive::Connection::SAS;
    my $connection_class = $result{class};
    $connection = $connection_class->connect(@$auth);
    Elive::SAS->connection($connection);

    my %insert_str_data = (
	sessionName => 'test session, generated by t/11-soap-session.t',
	creatorId => $connection->user,
    );

    my $dt = DateTime->now->truncate(to => 'minute');

    do {
	#
	# generate a date that's on the quarter hour and slightly into
	# the future (to allow for connection latency).
	#
	$dt->add(minutes => 1);
    } until ($dt->minute % 15 == 0 && $dt->epoch > time() + 10);

    my $session_start = $dt->epoch;
    my $session_end = $session_start + 900;

    $session_start .= '000';
    $session_end .= '000';

    my %insert_int_data = (
	startTime =>  $session_start,
	endTime => $session_end,
	openChair => 1,
	mustBeSupervised => 0,
	permissionsOn => 1,
    );

    my %insert_array_data = (
	groupingList => [qw(sewing mechanics)],
	);

    my ($session) = $class->insert({%insert_int_data, %insert_str_data, %insert_array_data});

    isa_ok($session, $class, 'session');
    ok(my $session_id = $session->sessionId, 'Insert returned session id');

    diag "session-id: $session_id";

    foreach (keys %insert_str_data) {
	#
	# returned record doesn't contain password
	ok($session->$_ eq $insert_str_data{$_}, "session $_ as expected");
    }

    foreach (keys %insert_int_data) {
	ok($session->$_ == $insert_int_data{$_}, "session $_ as expected");
    }

    foreach (keys %insert_array_data) {
	is_deeply([sort @{ $session->$_ }], [sort @{ $insert_array_data{$_} }], "session $_ as expected");
    }

    my %update_str_data = (
	chairNotes => 'test moderator notes. Here are some entities: & > <',
	nonChairNotes => 'test user notes; some more entities: &gt;',
    );
    
    my %update_int_data = (
	raiseHandOnEnter => 1,
	maxTalkers => 3,
	recordingModeType => 2,
	);

    $session->update({ %update_str_data,
		       %update_int_data});

    $session = undef;

    ok ($session = Elive::SAS::Session->retrieve([$session_id]),
	'Refetch of session');

    foreach (keys %update_str_data) {
	#
	# returned record doesn't contain password
	ok($session->$_ eq $update_str_data{$_}, "session update $_ as expected");
    }

    foreach (keys %update_int_data) {
	ok($session->$_ == $update_int_data{$_}, "session update $_ as expected");
    }

    my $attendances;

    dies_ok(sub {$attendances = $session->attendance('')}, 'session attendance sans date - dies');

    my $today_hires = DateTime->today->epoch.'000';
    lives_ok(sub {$attendances = $session->attendance($today_hires)}, 'session attendance with date - lives');

    lives_ok(sub {$session->delete},'session deletion - lives');

    my $deleted_session;
    eval {$deleted_session = Elive::SAS::Session->retrieve([$session_id])};

    ok($@ || !$deleted_session, "can't retrieve deleted session");
}

Elive->disconnect;

