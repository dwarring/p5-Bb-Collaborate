#!/usr/bin/perl
package Elive::script::elive_query;
use warnings; use strict;
use YAML;
use Carp;
use Getopt::Long qw{};

use Elive;
use Elive::Util;
use Elive::Entity;
use Elive::Entity::Group;
use Elive::Entity::Meeting;
use Elive::Entity::MeetingParameters;
use Elive::Entity::ParticipantList;
use Elive::Entity::Preload;
use Elive::Entity::Recording;
use Elive::Entity::Role;
use Elive::Entity::Report;
use Elive::Entity::ServerDetails;
use Elive::Entity::ServerParameters;
use Elive::Entity::User; 

use Term::ReadLine;
use Pod::Usage;
use UNIVERSAL;

use IO::Interactive;

=head1 NAME

elive_query

=head1 SYNOPSIS

  elive_query   http://myserver.com/my-site[:port]

    -user someuser              # server login user
    -pass somepass              # server login password
    -debug=n                    # 1=some, 2=verbose, 3=verbose + soap
    -dump=yaml                  # dump format
    -? -help                    # obtain help
    -v -version                 # print Elive version

=head1 DESCRIPTION

Simple read-only query shell for Elive. 

=head2 Entity Data Queries

This example script lets you do simple queries, in a vaguely SQL like manner.
For example:

    % elive_query -user admin http://myvclass.com/mysite
    Password: ********
    connecting to http://myvclass.com/mysite...ok
    Elive query 0.WX (Elluminate Live! 9.Y.Z)  (c) ... - type 'help' for help

    elive> select loginName,email,firstName,lastName,role from user where loginName like *m* 
    loginName   |email                 |firstName|lastName   |role
    ------------|----------------------|---------|-----------|----
    mr_miyagi   |mr_miyagi@hotmail.com |Pups     |Miyagi     |3
    sthrogmorton|sthrogmorton@gmail.com|Sebastion|Throgmorton|2

    elive>

=head2 Entity Metadata

You can also use this script to dump the Elive entity structures:

    elive> show
    usage: show group|meeting|meetingParameters|participantList|preload|recording|serverDetails|serverParameters|user

    elive> show meeting
    meeting: Elive::Entity::Meeting:
    meetingId         : pkey Int        
    deleted           : Bool
    end               : HiResDate    -- meeting end time
    facilitatorId     : Str          -- userId of facilitator
    name              : Str          -- meeting name
    password          : Str          -- meeting password
    privateMeeting    : Bool         -- don't display meeting in public schedule
    start             : HiResDate    -- meeting start time

    elive> 

=head1 SEE ALSO

perldoc Elive
L<http://search.cpan.org/dist/Elive/>

=cut

main(@ARGV) unless caller;

sub main {

    local(@ARGV) = @_;

    our $elive_version = ${Elive::VERSION};
    our $entities = Elive::Entity->entities;
    our $term = Term::ReadLine->new('elive shell');
    our $is_tty = IO::Interactive::is_interactive();

    foreach (keys %$entities) {
	#
	# Just want database mapped entities. Omit nested structures
	#
	delete $entities->{$_}
	unless ($entities->{$_}->isa('Elive::Entity')
		&& $entities->{$_}->primary_key);
    }

    my $prompt = "elive> ";

    my ($url, %options) = _getopt();

    our $debug = $options{debug};
    Elive->debug( $debug );

    our $connection;

    $connection = _connect($url, %options)
        if $url;

    my $server_version = '';

    if ($connection) {
	my $elive_version =  Elive->server_details->version
	    or warn "unable to get elluminate version";

	$server_version  = "(Elluminate Live! $elive_version) "
	    if $elive_version;
    }

    print "Elive query $elive_version (c) 2009 - 2010 $server_version. Type 'help' for help\n"
	if $is_tty;

    my $cmd;
    my $keyw;
    my $args;

    while (($keyw||'') ne 'quit'
	   && defined ($cmd = $is_tty? $term->readline($prompt): <STDIN>)
	) {

	$term->addhistory($cmd);
	#
	# strip leading white-space & trailing white-space + semicolon
	#
	$cmd =~ s{^ \s* (.*?) \s* ;? \s* $}{$1}x;

	if ($cmd =~ m{\S}) {

	    if (($keyw, $args) = ($cmd =~ m{^ (\w+) \s* (.*)? $}x)) {

		if (lc($keyw) eq substr('help',0, length($keyw))) {
		    print "Elive query $elive_version help:\n\n";
		    print "connect url [user] - connect to an Elluminate Live! server\n";
		    print "describe [entity_name] - list/show entities\n";
		    print "debug = [0|1|2|3] - set debugging level\n";
		    print "select <expr> from entity [where exp]\n";
		    print "    where expr is:\n";
		    print "      - prop1,prop2,.. - show selected properties\n";
		    print "      - *              - show all properties\n";
		    print "      - *?             - show only defined properties\n";
		    print "quit                   - exit elive_query\n\n";
		}
		elsif ($keyw  =~ m{^(connect)$}i) {
		    my ($url, $user) = split(m{\s+}, $args);

		    $url ||= Elive::Util::prompt("Url ('http://...'): ");

		    my $new_connection
			= _connect($url,
				   username => $user,
				   %options);

		    if ($new_connection) {
			$connection->disconnect if $connection;
			$connection = $new_connection;
		    }
		}
		elsif ($keyw  =~ m{^(debug)$}i) {
		    my ($level) = ($args =~ m{^\s* = \s* ([0-9])}x);

		    if (defined $level) {
			print "Debugging level set to $level\n";
			$level = $level + 0;

			$SIG{__WARN__} = $level > 1
			    ? \&Carp::cluck
			    : undef;

			$SIG{__DIE__} = $level
			    ? \&Carp::confess
			    : undef;

			Elive->debug($level);
		    }
		    else {
			print STDERR "usage: debug = 0..9";
		    }
		}
		elsif ($keyw =~ m{^(show|describe)$}i) {

		    if (my ($entity_name) = ($args =~ m{^ \s* (\w+) \s* $}x)) {
			_show($entities, $entity_name);
		    }
		    else {
			print 'usage: describe '.join('|', sort keys %$entities)."\n";
		    }
		}
		elsif (lc($keyw) eq 'select') {

		    warn "args: $args\n"
			if (Elive->debug);

		    my $valid;

		    if ($args =~ m{^
                          (.+?) \s+
                          from \s+ (\w+)?
                          (\s+ where \s+ (.*?))?
                          $}ix) {

			$valid = 1;

			my $entity = $2;
			my $filter = $4;
			my @props = split(m{\s* ,|\| \s*}x, $1);
			my $hide_undef = 0;

			my $entity_class = $entities->{$entity};

			if (!$entity_class) {
			    print STDERR "Unknown entity: $entity\n";
			    $valid = 0;
			}
			else {
			    if (@props == 1 && $props[0] =~ m{^(\*)(\??)$}) {
				#
				# '*'  select all
				# '*?' select all defined
				#
				$hide_undef = $2? 1: 0;
				@props = $entity_class->properties;
			    }
			    else {
				foreach (@props) {
				    $valid = 0 unless m{^ [a-zA-Z_-]+ $}x;
				}
			    }
			}

			if ($valid) {
			    warn "entity: $entity, filter: $filter, props: @props"
				if (Elive->debug);

			    unless ($connection) {
				print STDERR "you'll need to connect first - see help connect\n";
			    }
			    else {
				_select($entity_class, \@props,
					filter => $filter,
					hide_undef => $hide_undef,
					dump => $options{dump},
					); 
			    }
			}
		    }

		    unless ($valid) {
			print STDERR  "usage: select props|* from entity [where filter|id=val];\n";
		    }
		}
		elsif ($keyw !~ m{^(quit)$}) {
		    print STDERR "unrecognised command: $keyw, type 'help' for help\n";
		}
	}
	    else {
		print STDERR "unrecognised command  - type 'help' for help\n";
	    }
	}
    }

    Elive->disconnect;

    if (Elive->debug) {
	my @living = grep {$Elive::Entity::Elive_Objects->{$_}}
	(keys %Elive::Entity::Elive_Objects);

	print STDERR "about to shutdown, live objects: @living\n";
    }

    return 0;
}

########################################################################

sub _show {

    my ($entities, $entity_name, $nesting, $entity_class) = @_;

    $nesting ||= 0;
    my $sp = ' ' x ($nesting * 2);

    $entity_class ||= $entities->{$entity_name}
        or do {
	    print STDERR "${sp}Unknown entity: $entity_name\n";
	    return;
	};

    my $property_types = $entity_class->property_types;
    my $property_doco = $entity_class->property_doco;
    my ($pkey) = $entity_class->primary_key;

    print "${sp}$entity_name: $entity_class:\n"
	unless $nesting;

    foreach my $property ($entity_class->properties) {

	my ($type, $is_array, $is_entity) 
	    = Elive::Util::parse_type($property_types->{$property});

	my $is_primary = $pkey && $property eq $pkey;

	my $primary_str = $is_primary? 'pkey ': '';
	my $array_str = $is_array? ' []': '';

	printf("%-20s : %-16s", "$sp  $property", "${primary_str}${type}${array_str}");
	for ($property_doco->{$property}) {
	    print "\t-- $_" if $_;
	}
	print "\n";

	if ($is_entity) {
	    _show($entities, $property, $nesting + 1, $type);
	}

    }

    return;
}

sub _select {
    my ($entity_class, $props, %opt) = @_;

    my $filter = $opt{filter};
    my $hide_undef = $opt{hide_undef};

    my $property_types = $entity_class->property_types;
    my $entity_name = $entity_class->entity_name;
    my ($pkey) = $entity_class->primary_key;

    foreach (@$props) {
	
	unless (exists $property_types->{$_}) {
	    print STDERR "unknown $entity_name property: $_\n";
	    return;
	}
    }

    #
    # See if our filter is in the format: keyprop=val
    #
    warn "filter=$filter"
	if (defined $filter && Elive->debug);

    warn "entity: $entity_name, class: $entity_class"
	if (Elive->debug);
    warn join(' ', 'properties:',  $entity_class->properties)
	if (Elive->debug);

    #
    # Possible fetch on primary key or alternative key.
    # Detect and trap this as a simple fetch.
    #
    my $id;
    
    if (defined $filter) {
	if (my ($fld, $val) = ($filter =~ m{^ (\w+) \s* = \s* ([\w_\-\@\!\#\$\%\^\&\.\+]+) \s* $}x)) {
	    my $type = $property_types->{$fld} || '';
	    
	    if ($fld eq $pkey || $fld eq 'id') {
		$id = $val;
	    }
	}
    }

    my @output;
    my $rows;

    eval {
	if ($id) {
	    $rows =  [grep {$_} $entity_class->retrieve([$id])];
	}
	else {
	    $rows = $entity_class->list(filter => $filter);
	}
    };

    if ($@) {
	print "error:$@";
    }
    elsif (!@$rows) {
	print "No results.\n";
    }
    elsif ($opt{dump} && $opt{dump} =~ /^(yaml)$/i) {
        print YAML::Dump({$entity_name => [map {_fetch_row_href($props, $_)} @$rows]});
    }
    else {
	foreach my $row (@$rows) {
	    
	    my $row =  _fetch_row_aref($props, $row);
	    push(@output, $row);
	}

	#
	# pass 1: filter columns
	#

	my @show;

	foreach my $row (@output) {
	    
	    my $col = 0;

	    foreach (@$row) {
		$show[ $col++ ] ||= !$hide_undef || defined $_
		}
	}

	#
	# pass 2: compute output widths
	#

	my @widths;

	foreach  my $row ($props,@output) {

	    my $col = 0;

	    foreach (@$row) {

		my $this_width = length(defined($_)? $_ : '(undef)');

		for ($widths[ $col++ ]) {
		    $_ = $this_width
			if (!defined || $this_width > $_);
		}
	    }
	}
	
	#
	# pass 3: output
	#

	my @hrule = map {'-' x ($_||0)} @widths;

	foreach my $row ($props, \@hrule, @output) {

	    my $col = 0;
	    my @cols = (

			grep {$_}

			map {
			    my $v = defined($_) ? $_ : '(undef)';
			    my $s = $show[ $col ];
			    my $w = $widths[ $col ];
			    ++$col;
			    $s ? sprintf('%-*s', $w, $v)
				: undef;
			}

			@$row);

	    print join('|', map{defined($_) ? $_ : '(undef)'} @cols)."\n"; 
	}
    }

    return;
}

sub _fetch_row_aref {
    my $props = shift;
    my $row = shift;

    my @vals = (map {defined($_) ? Elive::Util::string($_) : undef}
		map {$row->$_}
		@$props);


    return \@vals;
}

sub _fetch_row_href {
    my $props = shift;
    my $row = shift;

    my %vals = (map {
	my $val = $row->$_;
	$val = defined($val) ? Elive::Util::string($val) : undef;
	$_ => $val
	} @$props);

    return \%vals;
}

sub _getopt {

    my %options;

    Getopt::Long::GetOptions(\%options,
			     'username|user=s',
			     'password|pass=s',
                             'dump=s',
			     'debug=i',
			     'help|?',
			     'version|v',
			     'help|?'
	) or die pod2usage(1);

    pod2usage(2) if ($options{help});

    if ($options{version}) {
	print "Elive v${Elive::VERSION} (c) 2009-2010\n";
	exit 0;
    }

    if ($options{dump} && $options{dump} !~ /^(yaml)$/i) {
	pod2usage("unknown dump format: $options{dump}");
    }

    my $url = shift(@ARGV);

    return ($url, %options);
}

sub _connect {
    my ($url,%options) = @_;

    my $username = $options{username};
    my $password = $options{password};

    $username ||= Elive::Util::prompt('Username: ');

    $password ||= Elive::Util::prompt('Password: ', password => 1);

    print STDERR "connecting to $url...";
    my $connection = eval {
	Elive->connect($url,$username, $password);
    };

    if ($@) {
	print "\nerror:$@";
	return;
    }

    print STDERR "ok\n";
    return $connection;
}
