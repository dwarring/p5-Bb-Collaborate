#!perl
use strict;
use warnings;
use File::Spec;
use Test::More;
use Test::Exception;
use English qw(-no_match_vars);

use lib '.';
use t::Elive;

use Elive;
use Elive::Entity::Meeting;

if ( not $ENV{TEST_AUTHOR} ) {
    my $msg = 'Author test.  Set $ENV{TEST_AUTHOR} to a true value to run.';
    plan( skip_all => $msg );
}

eval "use Test::Script::Run";

if ( $EVAL_ERROR ) {
    my $msg = 'Test::Script::Run required to run scripts';
    plan( skip_all => $msg );
}

unless (${Test::Script::Run::VERSION} >= '0.04') {
    my $msg = "Test::Script::Run version (${Test::Script::Run::VERSION} < 0.04)";
    plan( skip_all => $msg );
} 

plan(tests => 40);

local ($ENV{TERM}) = 'dumb';

my $script_name = 'elive_raise_meeting';

#
# try running script with --help
#

do {
    my ( $result, $stdout, $stderr ) = run_script($script_name, ['--help'] );
    ok($stderr eq '', "$script_name --help: stderr empty");
    ok($stdout =~ m{usage:}ix, "$script_name --help: stdout =~ 'usage:...''");
};
#
# try with invalid option
#

do {
    my ( $result, $stdout, $stderr ) = run_script($script_name, ['--invalid-opt']);

    ok($stderr =~ m{unknown \s+ option}ix, "$script_name invalid option message");
    ok($stdout =~ m{usage:}ix, "$script_name invalid option usage");

};

SKIP: {

    my %result = t::Elive->test_connection(only => 'real');
    my $auth = $result{auth};

    skip ($result{reason} || 'skipping live tests',
	  36)
	unless $auth && @$auth && $auth->[0] && $auth->[1] && $auth->[2];

    my $meeting_name = 'test meeting, generated by t/41-script-elive_raise_meeting.t';

    my @meeting_args = (
	$auth->[0],
	-user => $auth->[1], -pass => $auth->[2],
	-name => $meeting_name,
	);

    my $meeting_response_re = qr{^created meeting: (.*?) with id (\d+)$}im;

  MEETING_DEFAULTS:
    do {
	diag("*** TESTING MEETING DEFAULTS ****");
	my $time = time();
	my ( $result, $stdout, $stderr ) = run_script($script_name, \@meeting_args );
	diag("stderr:$stderr");
	diag("stdout:$stdout");

	ok($stderr eq '', "stderr empty");

	my ($ret_meeting_name, $ret_meeting_id) = ($stdout =~ $meeting_response_re);

	ok($ret_meeting_name, "meeting name returned");
	ok($ret_meeting_id, "meeting id returned");

	unless ($ret_meeting_name && $ret_meeting_id) {
		diag "unable to raise simple meeting - aborting";
		exit (1);
	}

	ok($ret_meeting_name eq $meeting_name, 'echoed meeting name as expected');

	my $connection_class = $result{class};
	my $connection = $connection_class->connect(@$auth)
	    or die "failed to connect?";

	my $meeting;
	ok($meeting = Elive::Entity::Meeting->retrieve([$ret_meeting_id], connection => $connection), 'retrieve');

	unless ($meeting) {
	    diag "unable to retrieve meeting: $ret_meeting_id - aborting";
	    exit (1);
	}

	ok($meeting->name eq $meeting_name, 'retrieved meeting name as expected');

	my $start = substr($meeting->start, 0, -3) + 0;
	my $end = substr($meeting->end, 0, -3) + 0;
	my $duration = $end - $start;

	diag sprintf("time=%d, start=%d, end=%d (duration: %d minutes)",
		     $time, $start, $end, $duration);

	ok ($start >= $time - 60 && $start <= $time + 16*60, "default start time within about 15 mins");


	ok($duration >= 9 * 60 && $duration <= 61 * 60 , "sensible default duration");

	lives_ok(sub {$meeting->delete}, 'deletion - lives');
    };

  BASIC_OPTIONS:
    do {
	diag("*** TESTING BASIC OPTIONS ****");
	my $weeks = 3;
	my $time = time();
	my $start_time = $time + 3600;
	my $end_time = $start_time + 1800;
	my @start = localtime($start_time);
	my @end   = localtime($end_time);

	my $start_str = sprintf("%04d-%02d-%02d %02d:%02d", $start[5]+1900, $start[4]+1, $start[3], $start[2], $start[1]);
	my $end_str = sprintf("%04d-%02d-%02d %02d:%02d", $end[5]+1900, $end[4]+1, $end[3], $end[2], $end[1]);
	my $meeting_pass = "test ".t::Elive::generate_id();

	my @basic_meeting_args = (
	    -occurs => "weeks=$weeks",
	    -start => $start_str,
	    -end   => $end_str,
	    -meeting_pass => $meeting_pass,
	    );

	diag("@basic_meeting_args");

	my ( $result, $stdout, $stderr ) = run_script($script_name,
						      [@meeting_args,
						       @basic_meeting_args,
						      ] );
	diag("stderr:$stderr");
	diag("stdout:$stdout");

	ok($stderr eq '', "stderr empty");

	my $connection_class = $result{class};
	my $connection = $connection_class->connect(@$auth)
	    or die "failed to connect?";

	my $last_meeting_start;
	my $week;

	my $resp = $stdout;

	#
	# meeting passwords are not returned directly. Instead we search
	# for meetings that contain the password.
	#
	my $meetings_with_this_password = Elive::Entity::Meeting->list(filter => "password = '$meeting_pass'", connection => $connection);

	while ($resp =~ s{$meeting_response_re}{}) {
	    $week++;
	    my $ret_meeting_name = $1;
	    my $ret_meeting_id   = $2;

	    ok($ret_meeting_name, "week $week: meeting name returned");
	    ok($ret_meeting_id, "week $week:meeting id returned");

	    ok($ret_meeting_name eq $meeting_name, "week $week: echoed meeting name as expected");

	    my $meeting;
	    ok($meeting = Elive::Entity::Meeting->retrieve([$ret_meeting_id], connection => $connection), "week $week: retrieve");

	    unless ($meeting) {
		diag "unable to retrieve meeting: $ret_meeting_id - aborting";
		exit (1);
	    }

	    if ($week == 1) {
		my $actual_start_time = substr($meeting->start, 0, -3);
		my $actual_end_time = substr($meeting->end, 0, -3);

		diag "requested start: $start_time => actual_start: $actual_start_time";
	
		ok(abs($actual_start_time - $start_time) <= 120, "week $week: actual start time as expected");	
		ok(abs($actual_end_time - $end_time) <= 120, "week $week: actual end time as expected");	
	    }

	    ok($meeting->name eq $meeting_name, "week $week: retrieved meeting name as expected");
	    ok(do {grep {$_->meetingId eq $ret_meeting_id} @$meetings_with_this_password}, "week $week: meeting password as expected");

	    my $start = substr($meeting->start, 0 , -3);

	    if ($last_meeting_start) {
		ok(t::Elive::a_week_between($last_meeting_start, $start), sprintf('weeks %d - %d: meetings separated by a week (approx)', $week-1,$week));
	    }

	    $last_meeting_start = $start;

	    lives_ok(sub {$meeting->delete}, "week $week: deletion - lives");
	}

	ok ($week == $weeks, "expected number of meeting repeats ($weeks)");
    }
}
